


compile:
	g++ -std=c++11 -c  -Wall -isystem . storage.cpp
clean:
	-rm *.o *.gch *.out *.exe *.dll *.obj

default:




# g++ -std=c++11 -c -O3 -Wall -isystem . test.cpp -o a.out

# run:
# 	./a.out



			// storage*
			// ofstream ofs;

			// for(auto i:{RELATIONSHIP_FILENAME,PERSON_FILNAME}){
			// 	ofs.open(i,ios_base::out|ios_base::trunc)
			// 	ofs.close();
			// }


/*
* 在家谱Genalogy中，所有已加入家谱中的Person都将获得一个唯一的
* 的id，使用id可以查询到具体某一个Person
* ======================================================
* 数据结构：采用一种类树的结构。
* 树的某个节点有三个指针：一个指向他的兄弟，一个指向他的孩子，另一个指向自己的母亲。
*     由于采用了母亲指针的方式，事实上这个家谱不是一棵严格意义上的树，
*     但如果把所有节点的母亲指针去掉，就是一棵完整的树了。
*
* 对某个给定的节点，要查找对应关系的方法：
* 父亲：遍历二叉树，直到找到孩子为给定节点的节点，为给定节点的父亲
* 母亲：直接访问母亲指针对应的节点
* 兄弟：得到父亲节点，并得到父亲所有的孩子
* 孩子：遍历孩子指针及孩子的兄弟
* 妻子：遍历所有的孩子，所有孩子母亲的集合，就是给定节点的妻子
*
*/

/*
* 输入：已存在的Person或id
* 输出：对应的id或Person对象
* 说明：当需要查询的Person不存在时，返回UNDEFINE_ID
*       当需要查询的id不存在时，返回一个默认构造的Person
*/
id_type getId(const Person& person);
const Person& getPersonById(id_type id) const;

/*
* 输入：已存在的Person或id
* 输出：对应的id或Person对象
* 说明：当母亲节点为空时，返回默认构造的Person
*/
Person& father(id_type id) const;
Person& monther(id_type id) const;

/*
* 输入：已存在id
* 输出：对应id父亲或母亲的id
* 说明：当母亲节点为空时，返回UNDEFINE_ID
*/
id_type getFather(id_type id) const;
id_type getMonther(id_type id) const;

/*
* 输入：已存在id
* 输出：对应id的兄弟（按大小排序），妻子（任意顺序），孩子（按大小排序）的vector集合
* 说明：当母亲节点为空时，返回UNDEFINE_ID
*/
vector<id_type> getBrother(id_type id) const;
vector<id_type> getWife(id_type id) const;
vector<id_type> getChild(id_type id) const;

/*
* 输入：已存在的一个Person
* 输出：若输入的Person存在，返回true；若不存在，返回false
* 说明：把输入的Person设置成树的根
*/
bool addRoot(const Person& grandFather);

	// const map<int,string> command{
	// 	{0,          ""},
	// 	{1,      "init"},
	// 	{2,"new_person"},
	// 	{3,     "birth"},
	// 	{4,       "die"}
	// }
	// de-facto initialized storage instance (before reading file)



		if(strcmp(argv[1],"new_person")==0){
			cout<<"Enter name, gender, "<<endl;
			exit(0);
		}


// void storage::init(){
// 	Graph h;
// 	g=h;
// 	sync();
// }

id_type  storage::getNewId()const{
	if(idMap.empty())
		return 0;
	return idMap.rbegin()->first+1;
}
void storage::addPerson(const Person p){
	// idMap[getNewId()]=p;
	idMap.emplace(getNewId(),p);
}

#define NO_MOTHER -1
// #define RELATIONSHIP_FILENAME "relationship.csv"

boost::detail::graph::read_graphviz_new(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, boost::detail::graph::mutate_graph*)'


boost::detail::graph::read_graphviz_new(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, boost::detail::graph::mutate_graph*)

// #define HUSBAND_WIFE_WEIGHT 1
// #define HUSBAND_WIFE_COLOR ""
// #define WIFE_SUBSPRING_WEIGHT 2
// #define WIFE_SUBSPRING_COLOR ""

	// no need to check if already mated (parallel edge disallowed)
	// if(!edge(v[0],v[1],mate).second)
	
// "unsigned" conflict with "NO_MOTHER"



# genealogy.out: \
# 	$(D_OUT)/util.o \
# 	$(D_OUT)/storage.o \
# 	$(D_OUT)/main.o
# 	$(CC) $^ $(F_LINK) -o $@


// id_t storage::getId(const Person& person);
// const Person& storage::getPersonById(id_type id) const{
// 	if(idMap.find(id)==idMap.end())
// 		throw runtime_error("This id does not refer to any person. A.K.A the person doesn't exist");
// 	return idMap.at(id);
// }
// Person& storage::father(id_t id) const;
// Person& storage::monther(id_t id) const;
// id_t storage::getFather(id_t id) const;
// id_t storage::getMonther(id_t id) const;
// vector<id_t> storage::getBrother(id_t id) const;
// vector<id_t> storage::getWife(id_t id) const;
// vector<id_t> storage::getChild(id_t id) const;
// bool storage::addRoot(const Person& grandFather);
// bool storage::addChild(id_t fatherId, id_t motherId, id_t childId);
// bool storage::removeChild(id_t id);
// void storage::traverse(function<void(const id_t id)>exec);

	// auto gpair=std::tie(idMap.at(v[0]).gender,idMap.at(v[1]).gender);
	// if(gpair!=make_tuple(FEMALE,MALE)&&gpair!=make_tuple(MALE,FEMALE))
	// 	throw runtime_error("No homosexuality please");
	// check incest
	// if

	// cout<<"syncing"<<endl;
	// add_edge(0,5,tree);
	// ofstream h("tree.dot");
	
	// ofstream m(MATE_FILENAME);
	// ofstream t(TREE_FILENAME);
	// ofstream r(RAIN_FILENAME);
 //  m.close();
 //  t.close();
 //  r.close();


// #include"read_graphviz_new.cpp"

	// // switch, father goes first
	// if(idMap.at(v[0]).gender==FEMALE)
	// 	std::swap(v[0],v[1]);

	// // check gender
	// if(std::tie(idMap.at(master).gender,idMap.at(slave).gender)!=make_tuple(MALE,FEMALE))
	// 	throw runtime_error("No homosexuality please");
	// incest


  // display_dot(MATE_FILENAME);
  // display_dot(TREE_FILENAME);
  // display_dot(RAIN_FILENAME);

	if(make_tuple(degree(r,mate),degree(r,tree),degree(r,rain))!=make_tuple(0,0,0))


int main() {
	Digraph dg;
	add_edge(0,3,dg);
	// for(unsigned i:{1,2})
	// 	remove_vertex(i,dg);


  // for (;vp.first != vp.second; ++vp.first){
  //   std::cout << *vp.first << "=" << index[*vp.first] <<  ", ";
  // }

	typedef property_map<Digraph, vertex_index_t>::type IndexMap;
	IndexMap index=get(vertex_index,dg);

	graph_traits<Digraph>::vertex_iterator vi, vi_end, next;
	tie(vi, vi_end) = vertices(dg);
	for (next = vi; vi != vi_end; vi = next) {
		++next;
		if(index[*vi]==1){
			remove_vertex(*vi,dg);
			break;
		}
	}

	write_graphviz(cout,dg);



	return 0;
}

  // first parameter: me
  // second parameter:my father or father whoever is part of the family
  // thrid parameter: mate of the second parameter (not part of the family)
  void join_parent(id_type,id_type,id_type);





	# test attach person with wife
	# 
	# test attach person with subspring
	# 
  // write_graphviz(ofsS[1],tree,default_writer(),my_vertex_writer(tree));
  // const char* name[] = { "dax.h", "yow.h", "boz.h", "zow.h", "foo.cpp",
  //                      "foo.o", "bar.cpp", "bar.o", "libfoobar.a",
  //                      "zig.cpp", "zig.o", "zag.cpp", "zag.o",
  //                      "libzigzag.a", "killerapp" };
  // write_graphviz(ofsS[1],tree,default_writer(),make_label_writer(name));
  // write_graphviz(ofsS[1],tree,default_writer(),make_label_writer(name));
  // write_graphviz(ofsS[2],rain);

  // person?

	# $E mate 0 1 2 3
	# $E display
	# $E mate 0 1 4 5

bool file_both_exist(){
	return(
		ifstream(execDir()+MATE_FILENAME)&&
		ifstream(execDir()+TREE_FILENAME)&&
		ifstream(execDir()+PERSON_FILNAME)
	);
}

#include"main.h"
using namespace std;


#include <boost/graph/graphviz.hpp>

enum files_e { dax_h, yow_h, boz_h, zow_h, foo_cpp,
               foo_o, bar_cpp, bar_o, libfoobar_a,
               zig_cpp, zig_o, zag_cpp, zag_o,
                 libzigzag_a, killerapp, N };
const char* name[] = { "dax.h", "yow.h", "boz.h", "zow.h", "foo.cpp",
                       "foo.o", "bar.cpp", "bar.o", "libfoobar.a",
                       "zig.cpp", "zig.o", "zag.cpp", "zag.o",
                       "libzigzag.a", "killerapp" };

  template <class Name>
  class label_writer {
  public:
    label_writer(Name _name) : name(_name) {}
    template <class VertexOrEdge>
    void operator()(std::ostream& out, const VertexOrEdge& v) const {
      // out << "[label=" << escape_dot_string(get(name, v)) << "]";
      out << "[label=" << "\"blahblah\"" << "]";
    }
  private:
    Name name;
  };
  template <class Name>
  inline label_writer<Name>
  make_label_writer(Name n) {
    return label_writer<Name>(n);
  }

int main(int,char*[])
{

  typedef pair<int,int> Edge;
  Edge used_by[] = {
    Edge(dax_h, foo_cpp), Edge(dax_h, bar_cpp), Edge(dax_h, yow_h),
    Edge(yow_h, bar_cpp), Edge(yow_h, zag_cpp),
    Edge(boz_h, bar_cpp), Edge(boz_h, zig_cpp), Edge(boz_h, zag_cpp),
    Edge(zow_h, foo_cpp),
    Edge(foo_cpp, foo_o),
    Edge(foo_o, libfoobar_a),
    Edge(bar_cpp, bar_o),
    Edge(bar_o, libfoobar_a),
    Edge(libfoobar_a, libzigzag_a),
    Edge(zig_cpp, zig_o),
    Edge(zig_o, libzigzag_a),
    Edge(zag_cpp, zag_o),
    Edge(zag_o, libzigzag_a),
    Edge(libzigzag_a, killerapp)
  };
  const int nedges = sizeof(used_by)/sizeof(Edge);
  int weights[nedges];
  std::fill(weights, weights + nedges, 1);

  using namespace boost;

  typedef adjacency_list< vecS, vecS, directedS,
      property< vertex_color_t, default_color_type >,
      property< edge_weight_t, int >
    > Graph;
  Graph g(used_by, used_by + nedges, weights, N);

  write_graphviz(std::cout, g, label_writer(name));
}


digraph G {
0;
1;
2;
3;
4;
5;
6;
7;
8;
9;
10;
11;
0->2 ;
2->3 ;
2->10 ;
2->11 ;
}
digraph G {
0;
1;
2;
3;
4;
5;
6;
7;
8;
9;
10;
11;
0->4 ;
4->5 ;
4->2 ;
4->3 ;
}