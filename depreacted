


compile:
	g++ -std=c++11 -c  -Wall -isystem . storage.cpp
clean:
	-rm *.o *.gch *.out *.exe *.dll *.obj

default:




# g++ -std=c++11 -c -O3 -Wall -isystem . test.cpp -o a.out

# run:
# 	./a.out



			// storage*
			// ofstream ofs;

			// for(auto i:{RELATIONSHIP_FILENAME,PERSON_FILNAME}){
			// 	ofs.open(i,ios_base::out|ios_base::trunc)
			// 	ofs.close();
			// }


/*
* 在家谱Genalogy中，所有已加入家谱中的Person都将获得一个唯一的
* 的id，使用id可以查询到具体某一个Person
* ======================================================
* 数据结构：采用一种类树的结构。
* 树的某个节点有三个指针：一个指向他的兄弟，一个指向他的孩子，另一个指向自己的母亲。
*     由于采用了母亲指针的方式，事实上这个家谱不是一棵严格意义上的树，
*     但如果把所有节点的母亲指针去掉，就是一棵完整的树了。
*
* 对某个给定的节点，要查找对应关系的方法：
* 父亲：遍历二叉树，直到找到孩子为给定节点的节点，为给定节点的父亲
* 母亲：直接访问母亲指针对应的节点
* 兄弟：得到父亲节点，并得到父亲所有的孩子
* 孩子：遍历孩子指针及孩子的兄弟
* 妻子：遍历所有的孩子，所有孩子母亲的集合，就是给定节点的妻子
*
*/

/*
* 输入：已存在的Person或id
* 输出：对应的id或Person对象
* 说明：当需要查询的Person不存在时，返回UNDEFINE_ID
*       当需要查询的id不存在时，返回一个默认构造的Person
*/
id_type getId(const Person& person);
const Person& getPersonById(id_type id) const;

/*
* 输入：已存在的Person或id
* 输出：对应的id或Person对象
* 说明：当母亲节点为空时，返回默认构造的Person
*/
Person& father(id_type id) const;
Person& monther(id_type id) const;

/*
* 输入：已存在id
* 输出：对应id父亲或母亲的id
* 说明：当母亲节点为空时，返回UNDEFINE_ID
*/
id_type getFather(id_type id) const;
id_type getMonther(id_type id) const;

/*
* 输入：已存在id
* 输出：对应id的兄弟（按大小排序），妻子（任意顺序），孩子（按大小排序）的vector集合
* 说明：当母亲节点为空时，返回UNDEFINE_ID
*/
vector<id_type> getBrother(id_type id) const;
vector<id_type> getWife(id_type id) const;
vector<id_type> getChild(id_type id) const;

/*
* 输入：已存在的一个Person
* 输出：若输入的Person存在，返回true；若不存在，返回false
* 说明：把输入的Person设置成树的根
*/
bool addRoot(const Person& grandFather);

	// const map<int,string> command{
	// 	{0,          ""},
	// 	{1,      "init"},
	// 	{2,"new_person"},
	// 	{3,     "birth"},
	// 	{4,       "die"}
	// }
	// de-facto initialized storage instance (before reading file)



		if(strcmp(argv[1],"new_person")==0){
			cout<<"Enter name, gender, "<<endl;
			exit(0);
		}


// void storage::init(){
// 	Graph h;
// 	g=h;
// 	sync();
// }

id_type  storage::getNewId()const{
	if(idMap.empty())
		return 0;
	return idMap.rbegin()->first+1;
}
void storage::addPerson(const Person p){
	// idMap[getNewId()]=p;
	idMap.emplace(getNewId(),p);
}

#define NO_MOTHER -1
// #define RELATIONSHIP_FILENAME "relationship.csv"

boost::detail::graph::read_graphviz_new(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, boost::detail::graph::mutate_graph*)'


boost::detail::graph::read_graphviz_new(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, boost::detail::graph::mutate_graph*)

// #define HUSBAND_WIFE_WEIGHT 1
// #define HUSBAND_WIFE_COLOR ""
// #define WIFE_SUBSPRING_WEIGHT 2
// #define WIFE_SUBSPRING_COLOR ""

	// no need to check if already mated (parallel edge disallowed)
	// if(!edge(v[0],v[1],mate).second)
	
// "unsigned" conflict with "NO_MOTHER"



# genealogy.out: \
# 	$(D_OUT)/util.o \
# 	$(D_OUT)/storage.o \
# 	$(D_OUT)/main.o
# 	$(CC) $^ $(F_LINK) -o $@


// id_t storage::getId(const Person& person);
// const Person& storage::getPersonById(id_type id) const{
// 	if(idMap.find(id)==idMap.end())
// 		throw runtime_error("This id does not refer to any person. A.K.A the person doesn't exist");
// 	return idMap.at(id);
// }
// Person& storage::father(id_t id) const;
// Person& storage::monther(id_t id) const;
// id_t storage::getFather(id_t id) const;
// id_t storage::getMonther(id_t id) const;
// vector<id_t> storage::getBrother(id_t id) const;
// vector<id_t> storage::getWife(id_t id) const;
// vector<id_t> storage::getChild(id_t id) const;
// bool storage::addRoot(const Person& grandFather);
// bool storage::addChild(id_t fatherId, id_t motherId, id_t childId);
// bool storage::removeChild(id_t id);
// void storage::traverse(function<void(const id_t id)>exec);

	// auto gpair=std::tie(idMap.at(v[0]).gender,idMap.at(v[1]).gender);
	// if(gpair!=make_tuple(FEMALE,MALE)&&gpair!=make_tuple(MALE,FEMALE))
	// 	throw runtime_error("No homosexuality please");
	// check incest
	// if

	// cout<<"syncing"<<endl;
	// add_edge(0,5,tree);
	// ofstream h("tree.dot");
	
	// ofstream m(MATE_FILENAME);
	// ofstream t(TREE_FILENAME);
	// ofstream r(RAIN_FILENAME);
 //  m.close();
 //  t.close();
 //  r.close();


// #include"read_graphviz_new.cpp"

	// // switch, father goes first
	// if(idMap.at(v[0]).gender==FEMALE)
	// 	std::swap(v[0],v[1]);

	// // check gender
	// if(std::tie(idMap.at(master).gender,idMap.at(slave).gender)!=make_tuple(MALE,FEMALE))
	// 	throw runtime_error("No homosexuality please");
	// incest







